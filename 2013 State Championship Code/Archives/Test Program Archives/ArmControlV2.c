#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     ,               sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     HTPB,           sensorI2CCustom9V)
#pragma config(Motor,  motorA,          RAMright,      tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          RAMleft,       tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     Right1,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     Right2,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     Left1,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     Left2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     elevatorA,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     elevatorB,     tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C4_1,    WAMrightServo,        tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    WAMleftServo,         tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    RampServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "..\Utilities\Robotc Includes\hitechnic-protoboard.h"

//initializes limit swithes as not pressed
int bottomLimit = 0;
int ringLimit = 0;
int ramLimit = 0;

// Servo Starting Positions.  These values are also used to restrict servo motion during tele-op operation.
//int WAMrightServoStart = 140;	// WAM Left Servo Start Point
//int WAMleftServoStart = 115;	// WAM Left Servo Start Point

// The following initialization code runs before the robot receives the start match command from the Field Control System
void initializeRobot()
{
	//Stop DC motors
	motor[Right1] = 0;
	motor[Right2] = 0;
	motor[Left1] = 0;
	motor[Left2] = 0;

	//Stop NXT motors
	motor[motorA] = 0;
	motor[motorB] = 0;
	motor[motorC] = 0;

	/*

	//Initialize Servos to starting positions
	servoChangeRate[WAMrightServo] = 10;   //Set how fast servo moves.  ROBOTC default is 10
	servoChangeRate[WAMleftServo] = 10;
	// Servo range:  0 - 255
	servo[WAMrightServo] = WAMrightServoStart;	// WAM Right Side
	servo[WAMleftServo] = WAMleftServoStart;	// WAM Left Side
	servo[RampServo] = 127;			// Ramp

	*/

	//Initialize Sensors
	HTPBsetupIO(HTPB, 0x0); //initializes the protoboard
	nMotorEncoder[elevatorA] = 0; //resets the elevator encoder

	return;
}

///////////////////////////////////////////////////////////////////////////////////////////////
//converts desired height in inches to raise/lower the arm to encoder ticks.
int inchesToTicks(float inches)
{
	int ticks;
	ticks=(int)((inches)*232.91); // 232.91 clicks per inch.
	return ticks;
}

float maxArmHeight = 45.25;	// Maximum Safe Arm Height used during manual control of the arm
int maxArmHeightTicks = inchesToTicks(maxArmHeight);

///////////////////////////////////////////////////////////////////////////////////////////////
// code to look at the limit switches. It might want to be it's own task and have the limit switches be globals so we can shut off the motors easily from anywhere in the code
// Note: swithes are "1" when pressed and "0" when not pressed
void ProcessProto()
{
	ubyte byteInput;
	int B3, B4;
	HTPBsetupIO(HTPB, 0x0);

	byteInput = HTPBreadIO (HTPB, 0x3f); //fetch the state of all the digital IO pins. They default as inputs.

	// the "& 0b__" clears the other values except the one identified in the binary string so the only "1" is for the desired position
	// the ">>" is a bit shift so that when say only the second swithc is switched, then the binary would be like "00010" but with the ">>1" opperator
	// it becomes "0001". this makes it so that the value of each of the variables is a 0 or 1 regardless of what other switches are pressed.

	//B0 input
	bottomLimit = ((byteInput)& 0b001); //currently, this is the bottom limit switch
	//B1 input
	ringLimit = ((byteInput) & 0b010) >> 1; //currently, is the switch fror the gripper
	//B2 input
	ramLimit = ((byteInput) & 0b100)>> 2;
	//B3 input
	B3 = ((byteInput) & 0b1000) >> 3;
	//B4 input
	B4 = ((byteInput) & 0b10000)>> 4;


	nxtDisplayCenteredTextLine(5, "Bottom Lim %d", bottomLimit);
	nxtDisplayCenteredTextLine(6, "Ring   Lim %d", ringLimit);
	nxtDisplayCenteredTextLine(7, "Ram    Lim %d", ramLimit);

	//for debugging purpose, to make sure the two switches are working electrically
	//nxtDisplayTextLine(0, "%d", (int) bottomLimit);
	//nxtDisplayTextLine(1, "%d", (int) ringLimit);
	//	wait10Msec(10);
}

void printProto()
{
	nxtDisplayCenteredTextLine(5, "Bottom Lim %d", bottomLimit);
	nxtDisplayCenteredTextLine(6, "Ring   Lim %d", ringLimit);
	nxtDisplayCenteredTextLine(7, "Ram    Lim %d", ramLimit);
}

//Arm Control////////////////////////////////////////////////////////////////////
void moveArm()
{
	eraseDisplay();
	// Enable Top Line NXT Display (Bluetooth, NXT Name & Battery Status)
	bNxtLCDStatusDisplay = true;
	nxtDisplayCenteredTextLine(1,"DITU SAYS WEAR");
	nxtDisplayCenteredTextLine(2,"SAFETY GLASSES");
	//------------------------------------------------
	if(nNxtButtonPressed == 1)
	{
		ClearTimer(T1);
		while(nMotorEncoder[elevatorA] < maxArmHeightTicks && time1[T1] < 100)
		{
			motor[elevatorA] = 70;
			motor[elevatorB] = 70;
		}
	}
	else
	{
		motor[elevatorA] = 0;
		motor[elevatorB] = 0;
	}
	//-------------------------------------------------
	if(nNxtButtonPressed == 2)
	{
		ClearTimer(T1);
		if(bottomLimit == 1)
		{
			motor[elevatorA] = 0;
			motor[elevatorB] = 0;
		}
		else if(bottomLimit == 0)
		{
			while((bottomLimit == 0 && ringLimit == 0)&& time1[T1] < 100)
			{
				motor[elevatorA] = -55;
				motor[elevatorB] = -55;
			}
		}
		else
		{
			motor[elevatorA] = 0;
			motor[elevatorB] = 0;
		}
	}

	//---------------------------------------------------------------
	if(nNxtButtonPressed == 3)
	{
		eraseDisplay();
	}
	//---------------------------------------------------------------
}

//////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot();	// Execute robot initialization routine
	maxArmHeight = 45.25;	// Maximum Safe Arm Height used during manual control of the arm
	maxArmHeightTicks = inchesToTicks(maxArmHeight);

	while(true)
	{
		//servo[WAMleftServo] = 40;
		//servo[WAMrightServo] = -40;
		//reads the protoboard to see which switches are pressed. Since they are globals, nothing is returned. We may want to make this it's own task eventually
		ProcessProto();
		//printProto();
		moveArm();

		nxtDisplayCenteredTextLine(5, "Bottom Lim %d", bottomLimit);
		nxtDisplayCenteredTextLine(6, "Ring   Lim %d", ringLimit);
		nxtDisplayCenteredTextLine(7, "Ram    Lim %d", ramLimit);
		// uses opportunity to reset the encoder if it is all the way at the bottom to help agianst compiling error
		if (bottomLimit == 1) nMotorEncoder[elevatorA] = 0;
	}
}
