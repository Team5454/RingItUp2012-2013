#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     Light,          sensorLightInactive)
#pragma config(Sensor, S3,     IR,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     Gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,          finger,        tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     LeftMotor,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     RightMotor,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     arm,           tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    bamLeft,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    bamRight,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

///////////////////////////////////////////////
/// File Name: Teleop.V1.c
/// Creator: Chris Beck, Joslyn, Sou
/// Date of Creation: [10/17/12], [10/19/12]
/// Last Editor: Chris Beck
///
/// Changes: Modifications to logic to enable correct functioning of code and corrections of errors.
///
/// Description:
///		The teleoperated main program
///
///////////////////////////////////////////////

// Gear settings
typedef struct
{
	int maxSpeed, minSpeed, scale;
	int button;
} Gear;
Gear currentGear; //Stores the current gear shift settings

//Rounds float value to integer
long round(float val)
{
	int dec = val - (int)val;
	val = val - dec;
	return val + (dec >= .5 ? 1.0 : 0.0);
}

//Maps a value between two ranges
long map(long x, long inMin, long inMax, long outMin, long outMax)
{
	return round((x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin);
}

//Filters a raw joystick value
int filterStick(int val)
{
	val = map(val, -127, 127, currentGear.minSpeed, currentGear.maxSpeed); //Scale the speeds;
	val *= currentGear.scale; // Scale Value (Usually used for mirroring)
	
  if (abs(val) < 10)        // core out the noise for near zero settings
    val = 0;
    
	return val;
}

void initializeRobot()
{
  // Stop all motors
  motor[RightMotor] = 0;
  motor[LeftMotor] = 0;
  motor[finger] = 0;
 	motor[arm] = 0;

  // Reset all the encoders
  nMotorEncoder[finger] = 0;
 	nMotorEncoder[arm] = 0;
  nMotorEncoder[LeftMotor] = 0;
  nMotorEncoder[rightMotor] = 0;
  
  // Initialize BAM down
  servoTarget[bamLeft] = 0;
  servoTarget[bamRight] = 255;

  // Initialize the current max speeds
  currentGear.maxSpeed = 127;
	currentGear.minSpeed = -127;
	currentGear.scale = 1;
 
  return;
}

//NXT power and safety checks
task backgroundWorker()
{
	nSchedulePriority	 = kLowPriority; //Set to low priority to avoid delaying other tasks

	for(;;)
	{
		alive(); //Keep the NXT from powering down
	}
}

task ditu_operator()
{
  // Anything other than driving should be done in this task 
	while(true)
	{
    // Operator
    //// Arm /////
    if(joy2Btn(5))   //up
    {
      motor[arm] = 20;
    }
    else if(joy2Btn(7)) //down
    {
		  motor[arm] = -20;
    }
  	else
	  {
		  motor[arm] = 0;
  	}

    //// Fingers ////
    if(joy2Btn(6))
    {
      nMotorEncoderTarget[finger] = 90;
      ClearTimer(T1);
      while ((nMotorEncoder[finger] < 90) && (time1[T1] < 500))
      {
        motor[finger] = 30;
   	  }
    }
    if(joy2Btn(8))
    {
      nMotorEncoderTarget[finger] = 0;
      ClearTimer(T1);
      while ((nMotorEncoder[finger] > 0) && (time1[T1] < 500))
      {
    	  motor[finger] = -30;
   	  }
   	  motor[finger] = 0;
    }

    // Driver     
    //// BAM ////
    if(joy1Btn(8)) //up
    {
      servoTarget[bamLeft] = 255;
      servoTarget[bamRight] = 0;
    }
    else if(joy1Btn(6)) // down
    {
      servoTarget[bamLeft] = 0;
      servoTarget[bamRight] = 255;
 	  }
	  else // default is at 90 deg
	  {
      servoTarget[bamLeft] = 127;
      servoTarget[bamRight] = 127;
    }
    
    wait1Msec(10); //Wait a bit to avoid interferring with more important systems (like I2C)
  }
}

task main()
{
	initializeRobot();             // Initialize Robot motors/servos and sensors
	
  StartTask(backgroundWorker);   // Task to keep the NXT Alive
	
	waitForStart();                // Wait for FCS Start
	
  StopTask(backgroundWorker);    // Stop the task to keep the NXT Alive
  
  StartTask(ditu_operator);      // Start the operator task
  
	while(true)                   // Look til stopped
	{
		getJoystickSettings(joystick);
		
		int jLeft = filterStick(joystick.joy1_y1);
		int jRight = filterStick(joystick.joy1_y2);

		//Drive train
    motor[LeftMotor] = jLeft;
    motor[RightMotor] = jRight;
      
    // Check for max power changes
		if(joy1Btn(1))                     // Left
		{
			currentGear.maxSpeed = 127;
			currentGear.minSpeed = -127;
			currentGear.scale = 1;
		}
		else if(joy1Btn(2))               // Bottom
		{
			currentGear.maxSpeed = 100;
			currentGear.minSpeed = -100;
			currentGear.scale = 1;
		}
		else if(joy1Btn(3))               // Right
		{
			currentGear.maxSpeed = 75;
			currentGear.minSpeed = -75;
			currentGear.scale = 1;
		}
		else if(joy1Btn(4))               // Top
		{
			currentGear.maxSpeed = 50;
			currentGear.minSpeed = -50;
			currentGear.scale = 1;
		}
	  wait1Msec(10); //Wait a bit to avoid interferring with more important systems (like I2C)
	}
  
  // Stop all Active Tasks
  StopAllTasks();
}
