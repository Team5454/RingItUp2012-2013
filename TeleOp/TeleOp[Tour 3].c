#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     HTPB,           sensorI2CCustom9V)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     Right1,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     Right2,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     Left1,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     Left2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     elevatorA,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     elevatorB,     tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C4_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    ramp,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "C:\Users\ditu\Documents\GitHub\RingItUp2012-2013\Utilities\Robotc Includes\hitechnic-protoboard.h"
int limit = 0;

///////////////////////////////////////////
///////////////////////////////////////////

void ProcessProto()
{
	ubyte byteInput;
	int intInput;
	//int proto.buttonVal = 0;
	int B0, B1, B2, B3, B4, ring = 0;
	HTPBsetupIO(HTPB, 0x0);

	// Fetch the state of the digital IO pins.  When not explicitly
	// configured as input or output, they will default to input.
	byteInput = HTPBreadIO (HTPB, 0x3f);
	intInput = ((int)byteInput-32);

	///////////////////////////////////////////
	///////////////////////////////////////////

	byteInput = (ubyte)intInput;

	B0 = ((byteInput)<< 11) >>11;
	B1 = (byteInput) >> 1;
	B2 = (byteInput) >> 2;
	B3 = (byteInput) >> 3;
	B4 = (byteInput) >> 4;

	if (B0 % 2 == 1 || B0 == 1)
		limit = 1;
	else
		limit = 0;

	if (B1 != 0)
		ring = 1;
	else
		ring = 0;

	//nxtDisplayTextLine(0, "%d", limit);
	wait10Msec(10);
}

///////////////////////////////////////////
///////////////////////////////////////////

task DeployRamp()
{
	while(true)
	{
		if(joy2Btn(10))
		{
			servo[ramp] = -100;
		}
		if(joy2Btn(9))
		{
			servo[ramp] = 100;
		}
	}
}

///////////////////////////////////////////
///////////////////////////////////////////

/*task drive()
{
while(true)
{
int jLeft = (int)joystick.joy1_y1;
int jRight =(int)joystick.joy1_y2;

if (abs(jLeft) <= 10)
{///< core out the noise for near zero settings
motor[Left1] = 0;
motor[Left2] = 0;///< sets the left motor to 0% power
}
else
{
int LeftCmd = jLeft*25/32;
motor[Left1] = LeftCmd;     ///< set motors to joystick settings
motor[Left2] = LeftCmd;
}
if (abs(jRight) <= 10)  {         ///< core out the noise for near zero settings
motor[Right1] = 0;        ///< sets the right motor to 0% power
motor[Right2] = 0;
}
else{
int RightCmd = jRight*25/32;
motor[Right1] = RightCmd;   ///< sets motors to joystick settings
motor[Right2] = RightCmd;
}
}
}
*/
//////////////////////////////////////////////////
////////////Task Main/////////////////////////////
//////////////////////////////////////////////////

task main()
{
	waitForStart();

	HTPBsetupIO(HTPB, 0x0);
	nMotorEncoder[elevatorA] = 0;
	int encoder;
	int desiredHeight = 20; //desired height to go to in inches
	int scaledDesiredHeight = (int)(desiredHeight - 2.7282)/.0043; //converts inches to encoder counts for test rig
	//	StartTask(drive);
	StartTask(DeployRamp);

	while(true)
	{
		getJoystickSettings(joystick);

		int jLeft = (int)joystick.joy1_y1;
		int jRight =(int)joystick.joy1_y2;

		if (abs(jLeft) <= 10)
		{///< core out the noise for near zero settings
			motor[Left1] = 0;
			motor[Left2] = 0;///< sets the left motor to 0% power
		}
		else
		{
			int LeftCmd = jLeft*25/32;
			motor[Left1] = LeftCmd;     ///< set motors to joystick settings
			motor[Left2] = LeftCmd;
		}
		if (abs(jRight) <= 10)  {         ///< core out the noise for near zero settings
			motor[Right1] = 0;        ///< sets the right motor to 0% power
			motor[Right2] = 0;
		}
		else{
			int RightCmd = jRight*25/32;
			motor[Right1] = RightCmd;   ///< sets motors to joystick settings
			motor[Right2] = RightCmd;
		}

		//		bDisplayDiagnostics = false;
		//		bNxtLCDStatusDisplay = false;
		ProcessProto();

		//		nxtDisplayCenteredTextLine(2, "Desired = %d", scaledDesiredHeight);
		//		nxtDisplayCenteredTextLine(4, "Limit = %d", limit);

		///////////////////////////////////////////
		///////////////////////////////////////////

		if(limit == 1)
		{
			if(joy1Btn(5))
			{
				motor[elevatorA] = 85;
				motor[elevatorB] = 85;
			}
			else
			{
				motor[elevatorA] = 0;
				motor[elevatorB] = 0;
			}
		}
		else
		{
			if(joy1Btn(5))
			{
				motor[elevatorA] = 85;
				motor[elevatorB] = 85;
			}
			else if(joy1Btn(7))
			{
				motor[elevatorA] = -55;
				motor[elevatorB] = -55;
			}
			else if(joy1Btn(1))
				nMotorEncoder[elevatorA] = 0;
			else
			{
				motor[elevatorA] = 0;
				motor[elevatorB] = 0;
			}
		}

		///////////////////////////////////////////
		///////////////////////////////////////////

		encoder = nMotorEncoder[elevatorA]*-1;

		if(joy1Btn(2))
		{
			while(encoder <= scaledDesiredHeight)
			{
				encoder = nMotorEncoder[elevatorA]*-1;
				motor[elevatorA] = 50;
				motor[elevatorB] = 50;
			}
			motor[elevatorA] = 0;
			motor[elevatorB] = 0;
		}

		//nxtDisplayCenteredTextLine(3, "Encoder = %d", encoder);


	}
}
