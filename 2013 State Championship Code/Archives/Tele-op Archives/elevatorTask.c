#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     backElevator,  tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     frontElevator, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    fourBar,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int readJoystick(int value)
{
	if (joy2Btn()) // 1 height
		value = (int)1440*18/(2*PI);
	else if (joy2Btn()) // 2 height
		value = (int)1440*32/(2*PI);
	else if (joy2Btn()) // 3 height
		value = (int)1440*46/(2*PI);
	return value;
}

void dispenseRings()
{
	int value = 0;
	servoTarget[fourBar] = 180;
	return;
}

int elevatorGoToHeight(int Xdesired)
{
	int Xcurrent;
	//int lifterEncoderVal;
	int touchValTop = 0;
	int touchValBottom = 0;
	bool automode;
	int elevatorDirection = 1;
	int proportionConstant = 1; // figure this out!!!!
	automode = true;
	Xcurrent = nMotorEncoder[frontElevator];

	while(Xcurrent != Xdesired && touchValBottom == 0 && touchValTop == 0)
	{
		Xdesired = readJoystick(Xdesired);  //reads controller to see if fickle user wants to go somewhere else instead

		//reads the touch value
		/*
		touchValBottom = SensorValue[TouchBottom];
		touchValTop = SensorValue[TouchTop];
		*/

		//reads where you are
		Xcurrent = nMotorEncoder[frontElevator];

		//tells the motor to reverse if it overshoots
		if (Xcurrent > Xdesired)
			elevatorDirection = elevatorDirection * -1;

		//calculates what the distance you still need to go and determines the adjusted speed
		errorX = Xdesired - Xcurrent;
		Xspeed = proportionConstant * errorX * elevatorDirection;

		//corrects speed for distances over 100
		if(abs(Xspeed) > 100)
			Xspeed = 100*elevatorDirection;

		//sets the speed of the motors

		motor[backElevator] = Xspeed*-1;
		motor[frontElevator] = Xspeed;
	}

	motor[backElevator] = 0;
	motor[frontElevator] = 0;


	if(joy2Btn(5))
	{
		dispenseRings();
	}

	return;
}



task Lifter()
{

	int Xdesired; // the encoder value of height we want to obtain
	int Xcurrent;
	//int lifterEncoderVal;
	int touchValTop;
	int touchValBottom;
	bool automode;
	int elevatorDirection = 1;
	int home = -5;
	automode = true;
	int joystickCurrent;


	while (true)
	{
		touchValBottom = SensorValue[TouchBottom];
		touchValTop = SensorValue[TouchTop];

		//following lines of code look to see if a button has been pressed. If it has, then it goes to the dictated position

		Xcurrent = nMotorEncoder[frontElevator];

		Xdesired = readJoystick(Xcurrent);

		if (Xdesired != Xcurrent)
			elevatorGoToHeight(Xdesired);

		dispenseRings();
		elevatorGoToHeight(home);

	}

}
