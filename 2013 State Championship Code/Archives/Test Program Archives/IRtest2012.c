#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     Light,          sensorLightInactive)
#pragma config(Sensor, S3,     IR,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     Gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,          finger,        tmotorNXT, openLoop, reversed)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     LeftMotor,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     RightMotor,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     arm,           tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    bamLeft,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    bamRight,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Measurments.V2.c"
#include "MoveCommandsV1[2012-2013].c"
#include "JoystickDriver.c"

task main()
{
		waitForStart();
	 	initializeRobot();
	 	initialize_gyro();
		StartTask(process_gyro);
	  motor[finger] = 40;

	  int irSensorVal;

	  // move forward, turn 45 degrees, move forward
	  move(1, 24, 2000);
	  wait10Msec(50);
	  move(1, 0, 1000);

		clearTimer(T1);

    //HTIRS2setDSPMode(InfraredSensor, DSP_1200);
    while (time1[T1] < 500)
   	{
   	    irSensorVal = SensorValue[IR];
        nxtDisplayBigTextLine(2, "IR: %d", irSensorVal);
  	}

  	if(irSensorVal == 1)
  	{
  			turngyro_left(-135.0, 50);
  			move(1, 19, 2000);
  			turngyro_left(90.0, 50);
  			move(1, 20, 2000);
  	}

  	if(irSensorVal == 2)
  	{
  		turngyro_left(-45.0, 50);
  		wait10Msec(50);

  		ClearTimer(T1);
  		nMotorEncoder[RightMotor] = 0;
  		nMotorEncoder[LeftMotor] = 0;

  		while((abs(nMotorEncoder[RightMotor]) < 114.588*16.5) || (time1[T1] < 5000))
  		{
  			nxtDisplayBigTextLine(2, "%d", nMotorEncoder[RightMotor]);
  		 	if(irSensorVal < 2)
  		 	{
  		 		motor[RightMotor] = -30;
  		 		motor[LeftMotor] = 30;
  		 	}
		 		if(irSensorVal == 2)
		 		{
		 			motor[RightMotor] = 30;
  		 		motor[LeftMotor] = 30;
		 		}
		 		if(irSensorVal > 2)
		 		{
		 			motor[RightMotor] = 30;
  		 		motor[LeftMotor] = -30;
		 		}
  		}
  	}

  	if(irSensorVal == 3)
  	{
  		while(true)
  		{
  			move(-1, 16.5, 2000);
  			turngyro_left(-45.0, 50);
  		}
  	}
        /*
        if (irSensorVal == 4)
        {
        		wait1Msec(500);
        		motor[Leftmotor] = 50;
            motor[Rightmotor] = 50;
            wait1Msec(500);

            PlaySound(soundLowBuzz);
        }

        if (irSensorVal == 3)
        {
       			motor[Leftmotor] = 30;
            motor[Rightmotor] = 60;
            PlaySound(soundFastUpwardTones)
        }

        if (irSensorVal == 5)
        {
       			motor[Leftmotor] = 30;
            motor[Rightmotor] = 60;
            PlaySound(soundFastUpwardTones);
        }

        if (irSensorVal < 3)
        {
       			motor[Leftmotor] = -50;
            motor[Rightmotor] = 50;
            //wait1Msec(200);

            PlaySound(soundFastUpwardTones);
        }

        if (irSensorVal > 5)
        {
        		motor[Leftmotor] = 50;
            motor[Rightmotor] = -50;
           	//wait1Msec(200);

            PlaySound(soundBeepBeep);
        }
        //else
        //{

        //}
        wait1Msec(50);


        //motor[LeftMotor] = -50;
        //motor[RightMotor] = -50;
        */

}
